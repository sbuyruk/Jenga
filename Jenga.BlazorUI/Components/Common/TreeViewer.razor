@using System
@using System.Linq
@using System.Collections.Generic
@using System.Threading.Tasks
@using Microsoft.AspNetCore.Components
@using Jenga.Models.Common
@using Jenga.Models.Helper
@typeparam T

<div class="d-flex align-items-start treeview-container">
    <div class="nav flex-column nav-pills gap-2 sticky-toolbar btn btn-light shadow " role="toolbar" aria-orientation="vertical">
        <button class="toolbar-btn" title="Genişlet" aria-label="Genişlet" tabindex="0" @onclick="ExpandAllNodes">
            <i class="bi bi-arrows-angle-expand" aria-hidden="true"></i>
        </button>
        <button class="toolbar-btn" title="Daralt" aria-label="Daralt" tabindex="0" @onclick="CollapseAllNodes">
            <i class="bi bi-arrows-angle-contract" aria-hidden="true"></i>
        </button>

        @if (SortSelector != null)
        {
            <button class="toolbar-btn" title="Sıralama yönünü değiştir" aria-label="Sıralama yönünü değiştir" tabindex="0" @onclick="ToggleSort">
                <i class="bi @(SortAscending ? "bi-sort-alpha-down" : "bi-sort-alpha-up")"></i>
            </button>
        }
    </div>

    <div class="col treeview-content">
        <ul class="treeview-list">
            @foreach (var item in FilteredItems)
            {
                <TreeNodeViewer T="T"
                                Item="item"
                                SelectedItemId="@SelectedItemId"
                                SelectedDataKey="@_selectedDataKey"
                                DataKeySelector="DataKeySelector"
                                OnSelect="HandleNodeSelect"
                                OnCreate="OnCreate"
                                OnEdit="OnEdit"
                                OnDelete="OnDelete"
                                LabelSelector="LabelSelector"
                                DescriptionSelector="DescriptionSelector"
                                SubItemLabelSelector="SubItemLabelSelector"
                                ChildrenSelector="ChildrenSelector"
                                ShowContextMenuSelector="ShowContextMenuSelector"
                                ShowCreateSelector="ShowCreateSelector"
                                ShowEditSelector="ShowEditSelector"
                                ShowDeleteSelector="ShowDeleteSelector"
                                OnSubItemCreate="OnSubItemCreate"
                                OnSubItemEdit="OnSubItemEdit"
                                OnSubItemDelete="OnSubItemDelete"
                                OnToggleExpand="HandleToggleExpand" />
            }
        </ul>
    </div>
</div>

@code {
    // --- Parameters ---
    [Parameter] public List<TreeItem<T>> Items { get; set; } = new();
    [Parameter] public string SearchTerm { get; set; } = "";
    [Parameter] public Func<TreeItem<T>, string, bool>? FilterFunc { get; set; }
    [Parameter] public Func<TreeItem<T>, string>? LabelSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, string>? SubItemLabelSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, string>? DescriptionSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, IEnumerable<TreeItem<T>>>? ChildrenSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, bool>? ShowContextMenuSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, bool>? ShowCreateSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, bool>? ShowEditSelector { get; set; }
    [Parameter] public Func<TreeItem<T>, bool>? ShowDeleteSelector { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnSelect { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnCreate { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnEdit { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnDelete { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnSubItemCreate { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnSubItemEdit { get; set; }
    [Parameter] public EventCallback<TreeItem<T>> OnSubItemDelete { get; set; }

    // DataKey selector provided by caller (stable key for selection across clones)
    [Parameter] public Func<TreeItem<T>, string>? DataKeySelector { get; set; }

    // --- Sorting parameters (two-way bind supported) ---
    [Parameter] public Func<TreeItem<T>, object?>? SortSelector { get; set; }
    [Parameter] public bool SortAscending { get; set; } = true;
    [Parameter] public EventCallback<bool> SortAscendingChanged { get; set; }

    // --- Internal state ---
    private string? SelectedItemId;
    private string? _selectedDataKey;

    // --- Preserve expansion state across parameter updates ---
    private List<TreeItem<T>>? _previousItems;
    private readonly Dictionary<string, bool> _expansionStates = new();

    // Expose filtered & sorted list for rendering.
    private IEnumerable<TreeItem<T>> FilteredItems
    {
        get
        {
            // If there's a search filter, use filtered and expanded set.
            List<TreeItem<T>> source;
            if (FilterFunc != null && !string.IsNullOrWhiteSpace(SearchTerm))
            {
                source = ExpandFiltered(TreeHelper.FilterTree(Items, item => FilterFunc(item, SearchTerm)));
            }
            else
            {
                // shallow clone list container so we can reorder without mutating caller reference
                source = Items?.Select(CloneShallow).ToList() ?? new List<TreeItem<T>>();
            }

            if (SortSelector != null)
            {
                var sorted = source.OrderByKey(SortSelector, SortAscending).ToList();
                foreach (var node in sorted) ApplySortRecursive(node);
                return sorted;
            }

            return source;
        }
    }

    // Notify local state and forward event to parent if provided
    private async Task HandleNodeSelect(TreeItem<T> item)
    {
        // store clicked node id (may be clone id) for immediate selection visuals
        SelectedItemId = item?.Id;
        // compute stable data key using provided selector
        _selectedDataKey = DataKeySelector?.Invoke(item) ?? item?.Id;

        if (OnSelect.HasDelegate)
            await OnSelect.InvokeAsync(item);

        // update UI
        StateHasChanged();
    }

    // New handler: toggle underlying item by id so original tree keeps expansion state
    private Task HandleToggleExpand(string id)
    {
        if (string.IsNullOrEmpty(id) || Items == null) return Task.CompletedTask;
        ToggleExpandById(Items, id);
        StateHasChanged();
        return Task.CompletedTask;
    }

    private bool ToggleExpandById(IEnumerable<TreeItem<T>> nodes, string id)
    {
        foreach (var node in nodes)
        {
            if (node.Id == id)
            {
                node.IsExpanded = !node.IsExpanded;
                return true;
            }
            if (node.Children != null && node.Children.Any() && ToggleExpandById(node.Children, id)) return true;
        }
        return false;
    }

    private List<TreeItem<T>> ExpandFiltered(List<TreeItem<T>> nodes)
    {
        if (nodes == null) return new List<TreeItem<T>>();
        foreach (var node in nodes) ExpandAll(node);
        return nodes;
    }

    private void ExpandAll(TreeItem<T> node)
    {
        if (node == null) return;
        node.IsExpanded = true;
        if (node.Children != null)
            foreach (var child in node.Children) ExpandAll(child);
    }

    private void CollapseAll(TreeItem<T> node)
    {
        if (node == null) return;
        node.IsExpanded = false;
        if (node.Children != null)
            foreach (var child in node.Children) CollapseAll(child);
    }

    private void ExpandAllNodes()
    {
        if (Items == null) return;
        foreach (var node in Items) ExpandAll(node);
    }

    private void CollapseAllNodes()
    {
        if (Items == null) return;
        foreach (var node in Items) CollapseAll(node);
    }

    private TreeItem<T> CloneShallow(TreeItem<T> source)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        return new TreeItem<T>
        {
            Id = source.Id,
            Data = source.Data,
            IsExpanded = source.IsExpanded,
            Children = source.Children != null ? source.Children.ToList() : null,
            ShowCreate = source.ShowCreate,
            ShowEdit = source.ShowEdit,
            ShowDelete = source.ShowDelete
        };
    }

    protected override void OnParametersSet()
    {
        // Capture expansion state from previous items (if any)
        _expansionStates.Clear();
        if (_previousItems != null)
            CaptureExpansionStates(_previousItems, _expansionStates);

        base.OnParametersSet();

        // Ensure sort is applied on parameter changes so parent-side rebind keeps ordering
        if (SortSelector != null && Items != null && Items.Any())
        {
            ApplySortToItems();
        }

        // Re-apply expansion state to newly provided Items
        if (_expansionStates.Count > 0 && Items != null)
            ApplyExpansionStates(Items, _expansionStates);

        // Remember current Items for next parameter change
        _previousItems = Items?.ToList();
    }

    private async Task ToggleSort()
    {
        SortAscending = !SortAscending;

        if (SortSelector != null && Items != null && Items.Any())
            ApplySortToItems();

        if (SortAscendingChanged.HasDelegate)
            await SortAscendingChanged.InvokeAsync(SortAscending);

        StateHasChanged();
    }

    private void ApplySortToItems()
    {
        if (SortSelector == null || Items == null) return;

        // Reassign root list ordered
        Items = Items.OrderByKey(SortSelector, SortAscending).ToList();

        // Recursively sort child lists
        foreach (var node in Items) ApplySortRecursive(node);
    }

    private void ApplySortRecursive(TreeItem<T> node)
    {
        if (node == null || node.Children == null || SortSelector == null) return;
        node.Children = node.Children.OrderByKey(SortSelector, SortAscending).ToList();
        foreach (var child in node.Children) ApplySortRecursive(child);
    }

    // Preserve/restore helpers
    private void CaptureExpansionStates(IEnumerable<TreeItem<T>>? nodes, Dictionary<string, bool> map)
    {
        if (nodes == null) return;
        foreach (var node in nodes)
        {
            if (node == null || string.IsNullOrEmpty(node.Id)) continue;
            map[node.Id] = node.IsExpanded;
            if (node.Children != null && node.Children.Any()) CaptureExpansionStates(node.Children, map);
        }
    }

    private void ApplyExpansionStates(IEnumerable<TreeItem<T>>? nodes, Dictionary<string, bool> map)
    {
        if (nodes == null) return;
        foreach (var node in nodes)
        {
            if (node == null || string.IsNullOrEmpty(node.Id)) continue;
            if (map.TryGetValue(node.Id, out var expanded)) node.IsExpanded = expanded;
            if (node.Children != null && node.Children.Any()) ApplyExpansionStates(node.Children, map);
        }
    }
}